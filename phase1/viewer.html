<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Sepolia On-chain Viewer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --page-width: 1040px;
      --gap: 14px;
      --radius: 14px;
      --border:#e5e7eb; --muted:#6b7280; --ink:#111827;
    }
    *{ box-sizing:border-box; }

    body{
      font-family: system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
      line-height:1.45;
      margin:18px auto;
      padding:0 18px;
      max-width: var(--page-width);
      background:#fff;
    }

    h1{ margin:0 0 14px; font-size:1.35rem; }
    h3{ margin:0 0 10px; font-size:1.05rem; }

    .card{
      border:1px solid var(--border);
      border-radius:var(--radius);
      padding:16px;
      margin:14px 0;
      box-shadow:0 1px 2px rgba(0,0,0,.04);
      background:#fff;
    }

    label{ display:block; font-size:.92rem; color:#374151; margin:0 0 6px; }

    input, textarea, select, button{
      font:inherit;
      width:100%;
      padding:11px 12px;
      border:1px solid #d1d5db;
      border-radius:10px;
      background:#fff;
    }
    textarea{ min-height:96px; resize:vertical; }
    .mono, code{ font-family: ui-monospace,SFMono-Regular,Menlo,Consolas,monospace; }

    .grid2{
      display:grid;
      gap:var(--gap);
      grid-template-columns: 1fr;
    }
    @media (min-width: 880px){
      .grid2{ grid-template-columns: 1fr 1fr; }
    }

    .row{
      display:flex; gap:var(--gap); flex-wrap:wrap; align-items:center;
      margin-top:8px;
    }
    .row > *{ flex: 1 1 220px; }

    .table-wrap{ overflow-x:auto; }
    table{ border-collapse:collapse; width:100%; min-width:680px; font-size:.94rem; }
    th, td{ border-bottom:1px solid var(--border); padding:10px; text-align:left; vertical-align:top; }
    th{ font-weight:600; color:#000; background:#f9fafb; }
    code{ background:#f3f4f6; padding:2px 6px; border-radius:6px; word-break:break-all; }

    button{ background:#111827; color:#fff; cursor:pointer; border:1px solid #111827; }
    button:disabled{ opacity:.55; cursor:not-allowed; }
    .muted{ color:var(--muted); }

    button{ padding: 12px 16px; margin: 8px 0; border-radius: 12px; }
    button + button{ margin-top: 12px; }
  </style>
</head>
<body>
  <div class="nav">
    <a href="index.html">← Home</a>
    <a href="register.html">MetaMask Console</a>
  </div>

  <h1>Sepolia On-chain Viewer</h1>

  <div class="card">
    <div class="grid2">
      <div><label>RPC URL</label><input id="rpc" value="https://<YOUR_RPC_URL>"></div>
      <div><label>Contract Address</label><input id="addr" value="0xYourContractAddress"></div>
      <div><label>Dataset ID (bytes32)</label><input id="datasetId" class="mono" value="0xYourDatasetId"></div>
      <div><label>Block range (start–end or “latest”)</label><input id="range" value="latest"></div>
    </div>
    <div class="row">
      <button id="go">Fetch DatasetRegistered</button>
      <span id="status" class="muted"></span>
    </div>
    <div class="row">
      <button id="goModels">Fetch ModelRegistered</button>
      <span id="statusModels" class="muted"></span>
    </div>
  </div>

  <div id="summary" class="card" style="display:none;"></div>
  <div id="table" class="card" style="display:none;">
    <h3 style="margin-top:0">DatasetRegistered</h3>
    <table>
      <thead><tr>
        <th>#</th><th>Block</th><th>Version</th><th>Merkle root</th><th>CID</th><th>Registrant</th><th>Gas used</th><th>Tx</th><th>Time (UTC)</th>
      </tr></thead>
      <tbody id="rows"></tbody>
    </table>
  </div>

  <div id="summaryModels" class="card" style="display:none;"></div>
  <div id="tableModels" class="card" style="display:none;">
    <h3 style="margin:0">ModelRegistered</h3>
    <table style="margin-top:12px;">
      <thead><tr>
        <th>#</th><th>Block</th><th>modelId</th><th>datasetId</th><th>dsVersion</th>
        <th>configHash</th><th>Registrant</th><th>Gas</th><th>Tx</th><th>Time (UTC)</th>
      </tr></thead>
      <tbody id="rowsModels"></tbody>
    </table>
  </div>  

  <div id="compareCard" class="card" style="display:none;">
    <h3 style="margin-top:0">Merkle Root Comparison</h3>
    <div class="grid2">
      <div><label>On-chain version to compare</label><select id="versionSelect"></select></div>
      <div><label>On-chain merkleRoot (selected version)</label><input id="onchainRoot" class="mono" readonly></div>
      <div><label>Your local merkleRoot (paste from Colab)</label><input id="localRoot" class="mono" placeholder="0x..."></div>
      <div><label>Result</label><input id="rootResult" class="mono" readonly></div>
    </div>
    <div class="row">
      <button id="btnCompare">Compare</button>
      <button id="btnUseForVerify">Use this version for Verify</button>
      <span id="statusCompare" class="muted"></span>
    </div>
  </div>



  <div class="card">
    <h3 style="margin-top:0">computeDatasetId(name)</h3>
    <div class="grid2">
      <div><label>Dataset name (string)</label><input id="dsName" placeholder="e.g., MIMIC-IV-demo-2.2"></div>
      <div><label>Result</label><input id="dsIdOut" class="mono" readonly></div>
    </div>
    <div class="row">
      <button id="btnCompute">Compute via Contract</button>
      <span id="statusCompute" class="muted"></span>
    </div>
  </div>

  <div class="card">
    <h3 style="margin-top:0">getModel(modelId)</h3>
    <div class="grid2">
      <div><label>modelId (bytes32)</label><input id="modelIdGet" class="mono" placeholder="0x..."></div>
      <div><label>Result</label><input id="modelOut" class="mono" readonly></div>
    </div>
    <div class="row">
      <button id="btnGetModel">Fetch</button>
      <span id="statusGetModel" class="muted"></span>
    </div>
  </div>

  <div class="card">
    <h3 style="margin-top:0">verifyFileHash(datasetId, version, leafHash, proof[])</h3>
    <div class="grid2">
      <div><label>datasetId (bytes32)</label><input id="v_ds" class="mono" placeholder="0x..."></div>
      <div><label>version (uint256)</label><input id="v_ver" type="number" min="1" step="1" value="1"></div>
      <div><label>leafHash (bytes32)</label><input id="v_leaf" class="mono" placeholder="0x..."></div>
      <div><label>proof (bytes32[], comma/space separated)</label><textarea id="v_proof" class="mono" placeholder="0x..., 0x..., 0x..."></textarea></div>
    </div>

    <div class="grid2" style="margin-top:8px;">
      <div>
        <label>Or load verify_bundle.json (from Colab)</label>
        <input id="verifyBundle" type="file" accept=".json">
      </div>
      <div style="display:flex; align-items:flex-end;">
        <button id="btnLoadBundle">Load bundle → fill fields</button>
      </div>
    </div>

    <div class="row">
      <button id="btnVerify">Verify</button>
      <span id="statusVerify" class="muted"></span>
    </div>
  </div>

  <div class="card" id="merkleExplorer">
    <h3 style="margin-top:0">Merkle Explorer (truncated)</h3>
    <p class="muted">Load <code>merkle_hashes.txt</code> to visualize the tree used in Phase 1 (sorted-pair; duplicate last when odd). Hashes are truncated for readability.</p>
    <div class="grid2">
      <div>
        <label>Load merkle_hashes.txt</label>
        <input id="mhFile" type="file" accept=".txt,text/plain">
      </div>
      <div>
        <label>Or paste contents</label>
        <textarea id="mhPaste" class="mono" placeholder="Paste the merkle_hashes.txt content here…" style="min-height:96px"></textarea>
      </div>
    </div>
    <div class="row">
      <button id="btnRenderTree">Render Merkle Tree</button>
      <label style="display:flex;align-items:center;gap:8px">
        <input type="checkbox" id="chkShowAll"> Show all leaves
      </label>
      <span id="mhStatus" class="muted"></span>
    </div>
    <div id="mhRoot" class="mono" style="margin-top:8px"></div>
    <div id="mhTree" style="margin-top:10px"></div>
  </div>


  <script src="https://cdn.jsdelivr.net/npm/ethers@6.11.1/dist/ethers.umd.min.js" crossorigin="anonymous"></script>
  <script>
  document.addEventListener('DOMContentLoaded', () => {
    const ABI = [
    {"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"addr","type":"address"},{"indexed":false,"internalType":"bool","name":"status","type":"bool"}],"name":"AuthorizationSet","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"datasetId","type":"bytes32"},{"indexed":false,"internalType":"uint256","name":"version","type":"uint256"},{"indexed":false,"internalType":"bytes32","name":"merkleRoot","type":"bytes32"},{"indexed":false,"internalType":"string","name":"metadataCID","type":"string"},{"indexed":true,"internalType":"address","name":"registrant","type":"address"},{"indexed":false,"internalType":"uint256","name":"timestamp","type":"uint256"}],"name":"DatasetRegistered","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"modelId","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"datasetId","type":"bytes32"},{"indexed":false,"internalType":"uint256","name":"datasetVersion","type":"uint256"},{"indexed":false,"internalType":"bytes32","name":"trainingConfigHash","type":"bytes32"},{"indexed":true,"internalType":"address","name":"registrant","type":"address"},{"indexed":false,"internalType":"uint256","name":"timestamp","type":"uint256"}],"name":"ModelRegistered","type":"event"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"authorized","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"string","name":"name","type":"string"}],"name":"computeDatasetId","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes32","name":"","type":"bytes32"},{"internalType":"uint256","name":"","type":"uint256"}],"name":"datasets","outputs":[{"internalType":"bytes32","name":"merkleRoot","type":"bytes32"},{"internalType":"string","name":"metadataCID","type":"string"},{"internalType":"uint256","name":"timestamp","type":"uint256"},{"internalType":"address","name":"registrant","type":"address"},{"internalType":"uint256","name":"version","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"datasetId","type":"bytes32"},{"internalType":"uint256","name":"version","type":"uint256"}],"name":"getDatasetVersion","outputs":[{"internalType":"bytes32","name":"merkleRoot","type":"bytes32"},{"internalType":"string","name":"metadataCID","type":"string"},{"internalType":"uint256","name":"timestamp","type":"uint256"},{"internalType":"address","name":"registrant","type":"address"},{"internalType":"uint256","name":"versionNum","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"datasetId","type":"bytes32"}],"name":"getDatasetVersions","outputs":[{"components":[{"internalType":"bytes32","name":"merkleRoot","type":"bytes32"},{"internalType":"string","name":"metadataCID","type":"string"},{"internalType":"uint256","name":"timestamp","type":"uint256"},{"internalType":"address","name":"registrant","type":"address"},{"internalType":"uint256","name":"version","type":"uint256"}],"internalType":"struct DatasetRegistry.DatasetVersion[]","name":"","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"modelId","type":"bytes32"}],"name":"getModel","outputs":[{"components":[{"internalType":"bytes32","name":"datasetId","type":"bytes32"},{"internalType":"uint256","name":"datasetVersion","type":"uint256"},{"internalType":"bytes32","name":"trainingConfigHash","type":"bytes32"},{"internalType":"uint256","name":"timestamp","type":"uint256"},{"internalType":"address","name":"registrant","type":"address"}],"internalType":"struct DatasetRegistry.ModelRecord","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"datasetId","type":"bytes32"}],"name":"latestDatasetVersion","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"name":"models","outputs":[{"internalType":"bytes32","name":"datasetId","type":"bytes32"},{"internalType":"uint256","name":"datasetVersion","type":"uint256"},{"internalType":"bytes32","name":"trainingConfigHash","type":"bytes32"},{"internalType":"uint256","name":"timestamp","type":"uint256"},{"internalType":"address","name":"registrant","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"datasetId","type":"bytes32"},{"internalType":"bytes32","name":"merkleRoot","type":"bytes32"},{"internalType":"string","name":"metadataCID","type":"string"}],"name":"registerDataset","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"modelId","type":"bytes32"},{"internalType":"bytes32","name":"datasetId","type":"bytes32"},{"internalType":"uint256","name":"datasetVersion","type":"uint256"},{"internalType":"bytes32","name":"trainingConfigHash","type":"bytes32"}],"name":"registerModel","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"modelId","type":"bytes32"},{"internalType":"bytes32","name":"datasetId","type":"bytes32"},{"internalType":"uint256","name":"datasetVersion","type":"uint256"},{"internalType":"bytes32","name":"trainingConfigHash","type":"bytes32"},{"internalType":"address","name":"ownerEOA","type":"address"}],"name":"registerModelOperator","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_addr","type":"address"},{"internalType":"bool","name":"_status","type":"bool"}],"name":"setAuthorized","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"datasetId","type":"bytes32"},{"internalType":"uint256","name":"version","type":"uint256"},{"internalType":"bytes32","name":"leafHash","type":"bytes32"},{"internalType":"bytes32[]","name":"proof","type":"bytes32[]"}],"name":"verifyFileHash","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"}
    ];

    const $ = (id) => document.getElementById(id);
    const short = (s, pre=6, post=4) => (s && s.length > (pre+post+2) ? s.slice(0,pre+2)+"…"+s.slice(-post) : s || "");
    const isBytes32 = (s) => /^0x[0-9a-fA-F]{64}$/.test(s);
    const isAddress = (s) => { try { ethers.getAddress(s); return true; } catch { return false; } };

    const parseRange = async (provider, raw) => {
      const head = await provider.getBlockNumber();
      if (!raw) return { start: Math.max(0, head - 50000), end: head };
      const parts = raw.split("-");
      const start = parseInt(parts[0], 10);
      if (Number.isNaN(start)) throw new Error(`Invalid start block: "${parts[0]}"`);
      const end = (parts.length === 1 || !parts[1] || parts[1].toLowerCase() === "latest") ? head :
        (Number.isNaN(parseInt(parts[1], 10)) ? (()=>{throw new Error(`Invalid end block: "${parts[1]}"`)})() : parseInt(parts[1],10));
      if (start > end) throw new Error(`Start block (${start}) > end block (${end})`);
      return { start, end };
    };

    const ensureProviderContract = async () => {
      const rpc = $("rpc").value.trim();
      const addr = $("addr").value.trim();
      if (!isAddress(addr)) throw new Error("Invalid contract address");
      const provider = new ethers.JsonRpcProvider(rpc);
      const code = await provider.getCode(addr);
      if (!code || code === "0x") throw new Error(`No contract code at ${addr} on Sepolia`);
      return { provider, addr, contract: new ethers.Contract(addr, ABI, provider) };
    };

    // --- Scan DatasetRegistered logs so we get block/tx/gas ---
    async function scanDatasetEvents(provider, addr, dsId, start, end) {
      const TOPIC0 = ethers.id("DatasetRegistered(bytes32,uint256,bytes32,string,address,uint256)");
      const step = 5000;
      const out = [];
      for (let from = start; from <= end; from += step) {
        const to = Math.min(from + step - 1, end);
        const logs = await provider.getLogs({ address: addr, fromBlock: from, toBlock: to, topics: [TOPIC0, dsId] });
        for (const log of logs) {
          const [version, merkleRoot, metadataCID, timestamp] =
            ethers.AbiCoder.defaultAbiCoder().decode(["uint256","bytes32","string","uint256"], log.data);
          const registrant = ethers.getAddress("0x" + log.topics[2].slice(26));
          let gasUsed = "";
          try {
            const rc = await provider.getTransactionReceipt(log.transactionHash);
            gasUsed = rc?.gasUsed?.toString?.() || "";
          } catch {}
          out.push({ version, merkleRoot, metadataCID, timestamp, registrant, _block: log.blockNumber, _tx: log.transactionHash, gasUsed });
        }
      }
      return out;
    }

    let _dsVersions = [];
    $("go").onclick = async () => {
      $("go").disabled = true; $("status").textContent = "Fetching dataset versions…";
      $("rows").innerHTML = ""; $("table").style.display="none"; $("summary").style.display="none"; $("compareCard").style.display="none";
      try {
        const { provider, addr } = await ensureProviderContract();
        const dsId = $("datasetId").value.trim();
        if (!isBytes32(dsId)) throw new Error("Dataset ID must be 0x + 64 hex chars");
        const { start, end } = await parseRange(provider, $("range").value.trim());

        const versions = await scanDatasetEvents(provider, addr, dsId, start, end);
        if (!versions.length) { $("status").textContent = "No versions found for that dataset."; $("go").disabled=false; return; }

        _dsVersions = versions.slice();
        const rows = versions.map((v,i)=>({
          idx:i+1, blockNumber:v._block || "", version:Number(v.version), merkleRoot:v.merkleRoot,
          cid:v.metadataCID, registrant:v.registrant, gasUsed:v.gasUsed||"", txHash:v._tx||"",
          iso: v.timestamp ? new Date(Number(v.timestamp)*1000).toISOString() : ""
        })).sort((a,b)=> (a.blockNumber||0)-(b.blockNumber||0));

        $("summary").style.display="block";
        $("summary").innerHTML = `<div><strong>${rows.length}</strong> version(s) for dataset <code class="mono">${short(dsId,10,8)}</code>. Contract <code class="mono">${short(addr,10,8)}</code>.</div>`;
        const tbody=$("rows"); tbody.innerHTML="";
        for(const r of rows){
          const tr=document.createElement("tr");
          tr.innerHTML=`
            <td>${r.idx}</td><td>${r.blockNumber??""}</td><td>${r.version}</td>
            <td><code class="mono" title="${r.merkleRoot}">${short(r.merkleRoot,10,10)}</code></td>
            <td>${r.cid?`<a href="https://ipfs.io/ipfs/${r.cid}" target="_blank">${short(r.cid,6,6)}</a>`:""}</td>
            <td>${r.registrant?`<a href="https://sepolia.etherscan.io/address/${r.registrant}" target="_blank">${short(r.registrant)}</a>`:""}</td>
            <td class="mono">${r.gasUsed||""}</td>
            <td>${r.txHash?`<a href="https://sepolia.etherscan.io/tx/${r.txHash}" target="_blank">${short(r.txHash)}</a>`:""}</td>
            <td class="mono">${r.iso}</td>`;
          tbody.appendChild(tr);
        }
        $("table").style.display="block";
        $("status").textContent = "Done.";

        const sel = $("versionSelect");
        sel.innerHTML = "";
        const sorted = versions.slice().sort((a,b)=> Number(a.version)-Number(b.version));
        for (const v of sorted) {
          const opt = document.createElement("option"); opt.value = String(Number(v.version)); opt.textContent = `Version ${Number(v.version)}`; sel.appendChild(opt);
        }
        const updateOnchainRoot = () => {
          const chosen = sorted.find(v => Number(v.version) === Number(sel.value));
          $("onchainRoot").value = chosen ? String(chosen.merkleRoot) : "";
          $("rootResult").value = ""; $("statusCompare").textContent = "";
        };
        sel.onchange = updateOnchainRoot;
        sel.value = sel.options[sel.options.length - 1]?.value || "";
        updateOnchainRoot();
        $("compareCard").style.display = "block";
      } catch(e){ console.error(e); $("status").textContent = `Error: ${e?.message||e}`; }
      finally { $("go").disabled=false; }
    };

    $("btnCompare").onclick = () => {
      const local = $("localRoot").value.trim().toLowerCase();
      const onchain = $("onchainRoot").value.trim().toLowerCase();
      if (!/^0x[0-9a-f]{64}$/.test(local)) { $("statusCompare").textContent = "Enter a valid 0x + 64-hex local merkleRoot."; $("rootResult").value = ""; return; }
      const match = local === onchain;
      $("rootResult").value = match ? "✅ MATCH" : "❌ MISMATCH";
      $("statusCompare").textContent = match ? "Roots match." : "Roots differ.";
    };
    $("btnUseForVerify").onclick = () => {
      $("v_ds").value = $("datasetId").value.trim();
      $("v_ver").value = $("versionSelect").value;
      $("statusCompare").textContent = "Copied datasetId + version into Verify section.";
    };

    // ----- Robust ModelRegistered scanner (keeps your block-start & full-width table) -----
    const sleep = (ms) => new Promise(r => setTimeout(r, ms));
    async function withRetry(fn, { tries=6, base=700 } = {}) {
      let last;
      for (let i=0;i<tries;i++){
        try { return await fn(); }
        catch (e){
          last = e;
          const msg = (e?.message||"") + " " + JSON.stringify(e?.info||{});
          if (msg.includes("Too Many Requests") || msg.includes("-32005") || msg.includes("timeout") || msg.includes("SERVER_ERROR")) {
            await sleep(base * Math.pow(1.6, i));
            continue;
          }
          throw e;
        }
      }
      throw last;
    }

    async function fetchModels() {
      const statusEl = $("statusModels") || $("status");
      const tbody  = $("rowsModels");
      const table  = $("tableModels");
      const sum    = $("summaryModels");

      statusEl.textContent = "Fetching model events…";
      tbody.innerHTML = ""; table.style.display="none"; sum.style.display="none";

      try {
        const { provider, addr } = await ensureProviderContract();
        const { start, end } = await parseRange(provider, $("range").value.trim());

        const TOPIC0 = ethers.id("ModelRegistered(bytes32,bytes32,uint256,bytes32,address,uint256)");
        const dsMaybe = $("datasetId").value.trim();
        const useFilter = isBytes32(dsMaybe);
        const topics = useFilter ? [TOPIC0, null, dsMaybe, null] : [TOPIC0];

        const logsAll = [];
        const step = 4500;
        for (let from = start; from <= end; from += step) {
          const to = Math.min(from + step - 1, end);
          const chunk = await withRetry(() =>
            provider.getLogs({ address: addr, fromBlock: from, toBlock: to, topics })
          );
          logsAll.push(...chunk);
          await sleep(500);
        }

        // Fallback: if filtered returned nothing, retry without filter
        if (!logsAll.length && useFilter) {
          const logsUnfiltered = [];
          for (let from = start; from <= end; from += step) {
            const to = Math.min(from + step - 1, end);
            const chunk = await withRetry(() =>
              provider.getLogs({ address: addr, fromBlock: from, toBlock: to, topics: [TOPIC0] })
            );
            logsUnfiltered.push(...chunk);
            await sleep(500);
          }
          logsAll.push(...logsUnfiltered);
        }

        if (!logsAll.length) {
          statusEl.textContent = "No ModelRegistered events in range.";
          return;
        }

        const rows = [];
        for (let i=0;i<logsAll.length;i++){
          const log = logsAll[i];
          const [datasetVersion, trainingConfigHash, timestamp] =
            ethers.AbiCoder.defaultAbiCoder().decode(["uint256","bytes32","uint256"], log.data);
          const modelIdX   = log.topics[1];
          const datasetIdX = log.topics[2];
          const registrant = ethers.getAddress("0x" + log.topics[3].slice(26));

          let gasUsed = "";
          try {
            const rc = await withRetry(() => provider.getTransactionReceipt(log.transactionHash));
            gasUsed = rc?.gasUsed?.toString?.()||"";
          } catch {}

          rows.push({
            idx:i+1,
            blockNumber:log.blockNumber,
            modelId:modelIdX,
            datasetId:datasetIdX,
            datasetVersion:Number(datasetVersion),
            trainingConfigHash,
            registrant,
            gasUsed,
            txHash:log.transactionHash,
            iso: new Date(Number(timestamp)*1000).toISOString()
          });
        }

        rows.sort((a,b)=> (a.blockNumber||0)-(b.blockNumber||0));

        sum.style.display="block";
        sum.innerHTML = `<div><strong>${rows.length}</strong> ModelRegistered event(s).</div>`;

        tbody.innerHTML = "";
        for (const r of rows) {
          const tr = document.createElement("tr");
          tr.innerHTML = `
            <td>${r.idx}</td><td>${r.blockNumber}</td>
            <td><code class="mono" title="${r.modelId}">${short(r.modelId,10,10)}</code></td>
            <td><code class="mono" title="${r.datasetId}">${short(r.datasetId,10,10)}</code></td>
            <td>${r.datasetVersion}</td>
            <td><code class="mono" title="${r.trainingConfigHash}">${short(r.trainingConfigHash,10,10)}</code></td>
            <td><a href="https://sepolia.etherscan.io/address/${r.registrant}" target="_blank">${short(r.registrant)}</a></td>
            <td class="mono">${r.gasUsed}</td>
            <td><a href="https://sepolia.etherscan.io/tx/${r.txHash}" target="_blank">${short(r.txHash)}</a></td>
            <td class="mono">${r.iso}</td>`;
          tbody.appendChild(tr);
        }

        table.style.display="block";
        statusEl.textContent = "Done.";
      } catch (e) {
        console.error(e);
        ( $("statusModels") || $("status") ).textContent = `Error: ${e?.message||e}`;
      }
    }
    $("goModels").addEventListener("click", fetchModels);

    $("btnCompute").onclick = async () => {
      $("btnCompute").disabled = true; $("statusCompute").textContent = "Computing…";
      try {
        const { contract } = await ensureProviderContract();
        const name = $("dsName").value; if (!name) throw new Error("Enter a dataset name");
        $("dsIdOut").value = await contract.computeDatasetId(name);
        $("statusCompute").textContent = "Done.";
      } catch(e){ console.error(e); $("statusCompute").textContent = `Error: ${e?.message||e}`; }
      finally { $("btnCompute").disabled=false; }
    };

    $("btnGetModel").onclick = async () => {
      $("btnGetModel").disabled = true; $("statusGetModel").textContent = "Fetching…";
      try {
        const { contract } = await ensureProviderContract();
        const mid = $("modelIdGet").value.trim();
        if (!isBytes32(mid)) throw new Error("modelId must be bytes32");
        const rec = await contract.getModel(mid);
        $("modelOut").value = JSON.stringify({
          datasetId: rec.datasetId, datasetVersion: Number(rec.datasetVersion),
          trainingConfigHash: rec.trainingConfigHash, timestamp: Number(rec.timestamp),
          registrant: rec.registrant
        }, null, 2);
        $("statusGetModel").textContent = "Done.";
      } catch(e){ console.error(e); $("statusGetModel").textContent = `Error: ${e?.message||e}`; }
      finally { $("btnGetModel").disabled=false; }
    };

    $("btnVerify").onclick = async () => {
      $("btnVerify").disabled = true; $("statusVerify").textContent = "Verifying…";
      try {
        const { contract } = await ensureProviderContract();
        const ds = $("v_ds").value.trim(), ver = parseInt($("v_ver").value,10), leaf = $("v_leaf").value.trim();
        const proof = $("v_proof").value.trim() ? $("v_proof").value.trim().split(/[\s,]+/).filter(Boolean) : [];
        const isB32 = (x)=>/^0x[0-9a-fA-F]{64}$/.test(x);
        if (!isB32(ds)) throw new Error("datasetId must be bytes32");
        if (!Number.isInteger(ver) || ver < 1) throw new Error("version must be a positive integer");
        if (!isB32(leaf)) throw new Error("leafHash must be bytes32");
        for (const p of proof) if (!isB32(p)) throw new Error(`Invalid proof element: ${p}`);
        const ok = await contract.verifyFileHash(ds, ver, leaf, proof);
        $("statusVerify").textContent = ok ? "✅ Proof is valid (included)" : "❌ Not included / bad proof";
      } catch(e){ console.error(e); $("statusVerify").textContent = `Error: ${e?.message||e}`; }
      finally { $("btnVerify").disabled=false; }
    };

    // --- Verify bundle loader (also maps root → version by scanning) ---
    document.getElementById('btnLoadBundle').onclick = async () => {
      const st = document.getElementById('statusVerify');
      const fileInp = document.getElementById('verifyBundle');
      if (!fileInp.files?.[0]) { st.textContent = 'Pick a JSON file first.'; return; }

      try {
        const jb = JSON.parse(await fileInp.files[0].text());

        const ds    = jb.datasetId || jb.dataset_id;
        const ver   = jb.version   ?? jb.datasetVersion ?? jb.dsVersion;
        const leaf  = jb.leafHash  || jb.leaf || jb.targetLeaf || jb.target_leaf;
        const proof = jb.proof     || jb.proofArray;
        const root  = jb.merkleRoot || jb.root;

        if (ds)   $('v_ds').value   = ds;
        if (leaf) $('v_leaf').value = leaf;
        if (Array.isArray(proof)) $('v_proof').value = proof.join(', ');

        if (ds && root) {
          const { provider, addr } = await ensureProviderContract();
          const { start, end } = await parseRange(provider, $('range').value.trim());
          const versions = await scanDatasetEvents(provider, addr, ds, start, end);
          const hit = versions.find(v => String(v.merkleRoot).toLowerCase() === String(root).toLowerCase());
          if (hit) $('v_ver').value = String(Number(hit.version));
          else if (ver != null) $('v_ver').value = String(ver);
        } else if (ver != null) {
          $('v_ver').value = String(ver);
        }

        if ($('v_ds').value && $('v_ver').value && $('v_leaf').value && $('v_proof').value)
          st.textContent = 'Loaded all fields ✔';
        else
          st.textContent = 'Loaded some fields; check version/leaf/proof.';
      } catch (e) {
        console.error(e);
        st.textContent = `Error: ${e.message || e}`;
      }
    };
  });
  
  </script>

  <script>
  (function(){
    const $ = (id)=>document.getElementById(id);
    const trunc = (hx)=> (typeof hx==="string" && hx.startsWith("0x") && hx.length>18)
                        ? (hx.slice(0,10) + "…" + hx.slice(-6)) : hx;

    function parseMerkleHashes(text) {
      const lines = (text||"").split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
      let root = "";
      const leaves = []; // {file, hash}
      for (const ln of lines) {
        // Root line examples: "MERKLE ROOT: 0x...", "Merkle Root: 0x..."
        const mRoot = ln.match(/merkle\s*root\s*:\s*(0x[0-9a-fA-F]{64})/i);
        if (mRoot) { root = mRoot[1]; continue; }
        // File line examples: "tokenized_admissions.jsonl: 0x...."
        const mFile = ln.match(/^(.+?):\s*(0x[0-9a-fA-F]{64})$/);
        if (mFile) {
          leaves.push({ file: mFile[1].trim(), hash: mFile[2] });
        }
      }
      return { root, leaves };
    }

    // Recompute the entire tree (sorted-pair with duplicate-last)
    function buildTree(leaves) {
      if (!leaves.length) return { levels: [], root: "" };
      // Build level 0 (bytes)
      const L0 = leaves.map(l => l.hash);
      const levels = [ L0.slice() ];
      let level = L0.slice();
      while (level.length > 1) {
        if (level.length % 2 === 1) level.push(level[level.length-1]);
        const next = [];
        for (let i=0; i<level.length; i+=2) {
          const a = level[i], b = level[i+1];
          // sorted pair keccak
          const ab = (a.toLowerCase() < b.toLowerCase())
            ? ethers.solidityPackedKeccak256(["bytes32","bytes32"], [a,b])
            : ethers.solidityPackedKeccak256(["bytes32","bytes32"], [b,a]);
          next.push(ab);
        }
        levels.push(next);
        level = next;
      }
      return { levels, root: level[0] };
    }

    function renderTree(container, files, tree, showAll) {
      container.innerHTML = "";
      const levels = tree.levels;
      const wrap = document.createElement("div");
      wrap.style.display = "grid";
      wrap.style.gap = "10px";

      // Leaves: show filenames → truncated hash (first 10, unless showAll)
      const leavesCard = document.createElement("div");
      leavesCard.innerHTML = `<div class="muted" style="margin:4px 0">Leaves (n=${files.length})</div>`;
      const ul = document.createElement("ul");
      ul.style.margin = "6px 0 0 0";
      ul.style.paddingLeft = "18px";
      const maxShow = showAll ? files.length : Math.min(files.length, 10);
      for (let i=0; i<maxShow; i++) {
        const li = document.createElement("li");
        li.className = "mono";
        li.textContent = `${files[i].file} → ${trunc(files[i].hash)}`;
        ul.appendChild(li);
      }
      if (!showAll && files.length > maxShow) {
        const li = document.createElement("li");
        li.className = "mono muted";
        li.textContent = `… ${files.length - maxShow} more`;
        ul.appendChild(li);
      }
      leavesCard.appendChild(ul);
      wrap.appendChild(leavesCard);

      // Internal levels (compact)
      for (let lvl = 1; lvl < levels.length; lvl++) {
        const L = levels[lvl];
        const card = document.createElement("div");
        card.innerHTML = `<div class="muted" style="margin:4px 0">Level ${lvl} (size=${L.length})</div>`;
        const row = document.createElement("div");
        row.style.display = "flex";
        row.style.flexWrap = "wrap";
        row.style.gap = "8px";
        const lim = showAll ? L.length : Math.min(L.length, 10);
        for (let i=0; i<lim; i++) {
          const chip = document.createElement("code");
          chip.className = "mono";
          chip.style.border = "1px solid #e5e7eb";
          chip.style.borderRadius = "8px";
          chip.style.padding = "4px 8px";
          chip.textContent = trunc(L[i]);
          row.appendChild(chip);
        }
        if (!showAll && L.length > lim) {
          const more = document.createElement("span");
          more.className = "mono muted";
          more.style.padding = "4px 8px";
          more.textContent = `… ${L.length - lim} more`;
          row.appendChild(more);
        }
        card.appendChild(row);
        wrap.appendChild(card);
      }
      container.appendChild(wrap);
    }

    async function loadTextFromFile(inputEl) {
      const f = inputEl.files?.[0];
      if (!f) return "";
      return await f.text();
    }

    $("btnRenderTree").onclick = async ()=>{
      $("mhStatus").textContent = "Parsing…";
      try{
        let text = $("mhPaste").value.trim();
        if (!text) text = await loadTextFromFile($("mhFile"));
        if (!text) throw new Error("Provide merkle_hashes.txt (file or paste).");

        const parsed = parseMerkleHashes(text);
        if (!parsed.leaves.length) throw new Error("No leaves found in the text.");
        // Build tree and compare root (if root line exists)
        const tree = buildTree(parsed.leaves);
        $("mhRoot").innerHTML =
          `<div class="mono">Computed root: <b>${tree.root}</b>${
            parsed.root ? ` &nbsp; | &nbsp; Provided: ${parsed.root} &nbsp; ${
              (parsed.root.toLowerCase()===tree.root.toLowerCase()) ? "✅" : "❌"
            }` : ""
          }</div>`;

        renderTree($("mhTree"), parsed.leaves, tree, $("chkShowAll").checked);
        $("mhStatus").textContent = "Rendered.";
      }catch(e){
        $("mhStatus").textContent = "Error: " + (e.message||e);
      }
    };

    $("chkShowAll").onchange = ()=>{
      // re-render if we already have a tree on screen
      const rootText = $("mhRoot").textContent || "";
      if (!rootText) return;
      // quick re-run render using last parsed leaves if you want to cache;
      // simplest is to click Render again:
      $("btnRenderTree").click();
    };
  })();
  </script>

</body>
</html>
